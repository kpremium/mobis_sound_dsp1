/*********************************************************************************

Copyright(c) 2018 Analog Devices, Inc. All Rights Reserved.

This software is proprietary and confidential.  By using this software you agree
to the terms of the associated Analog Devices License Agreement.

 *********************************************************************************/

/** @addtogroup Init_Preload_2156x Processor Initialization Code
 *  @{
 *
 *            This program is used to generate both Initialization and Preload codes.
 *
 *            The Preload executable is used as part of debugging via CCES, to initialize CGU and DMC
 *            (clocks and DDR controller) before downloading and debugging the actual application.
 *
 *            The Initialization executable (Init block) is used as part of the Boot process to initialize above blocks
 *            before booting the rest of the application. Additionally, macros are provided in order to reinitialize
 *            the clocks to assist in efficiently reducing the overall boot time. This includes the following:
 *            - UART Slave boot: Once CGU is initialized the UART Baud rate would need to be recalculated and reinitialized.
 *            - SPI Master boot: SPI clock rate can be reinitialized as desired.
 *            - OSPI Master boot: OSPI clock rate can be reinitialized as desired.
 *
 *           The project has dependency on certain macros to enable functionality for above cases.
 *
 *           Common macros:
 *
 *           - #CLKIN - Provide the CLKIN value used in the system. This is used for baud rate calculations.
 *           - #CONFIG_DMC0 - Define as 0, if there is no DDR on the board or the chip.
 *                            If this macro is defined as 0, then SMPU driver is invoked to prevent further access.
 *                            If this macro is defined as a non-zero value, then DDR Controller registers are configured by adi_dmc_cfg0_init().
 *           - #CONFIG_SPIFLASH - Define as 0, if there is no SPI Flash on the board or the chip.
 *                            If this macro is defined as 0, then SMPU driver is invoked to prevent further access.
 *           - #DO_PROCESS_BOOTSTRUCT - Define as 1, if there is need to process the boot struct passed by ROM.
 *                            If this macro is defined as 1, then the software can process the boot struct parameters.
 *                            No example is provided by default, user can consult Hardware Reference Manual.
 *           - #EXECUTE_SAFE_STATE - Define as 1, if the program must go in to a safe state up on errors in the API calls
 *                            If this macro is defined as 1, then the program would go in to safe state up on error
 *                            detection from the configuration APIs called earlier. By default an infinite loop is implemented.
 *
 *           Boot related macros for the init code:
 *           - #CONFIG_BOOT_UART_BAUD_RATE - Define as 1, if the UART Baud Rate need to be recalculated and reinitialized
 *                                           This is applicable only for UART Slave booting.
 *           - #CONFIG_BOOT_SPI_CLOCK_RATE - Define as 1, if the SPI Clock Rate need to be recalculated and reinitialized
 *                                           This is applicable only for SPI Master booting.
 *           - #CONFIG_BOOT_OSPI_CLOCK_RATE- Define as 1, if the OSPI Clock Rate need to be recalculated and reinitialized
 *                                           This is applicable only for OSPI Master booting.
 *           - #CONFIG_BOOT_SPI_CLOCK_VAL  - Macro for the new SPI Clock rate value
 *           - #CONFIG_BOOT_OSPI_CLOCK_VAL - Macro for the new OSPI Clock rate value
 *           - #CONFIG_BOOT_OSPI_READCAPDELAY - Macro for the OSPI Read Cap Delay value
 *
 *           If the clock frequencies must be changed, the CCES CGU Plugin can be used.
 *           adi_pwr_2156x_config.c file is similar to the template output file generated by this plugin.
 *           This file can be replaced with the new configuration file. Consult the documentation of the
 *           plugin for new information. Consult adi_pwr_2156x_config.c file for the default CGU settings used.
 *
 *           If the DMC settings must be changed the CCES DMC Plugin can be used.
 *           adi_dmc_2156x_config.c file is similar to the template output file generated by this plugin.
 *           This file can be replaced with the new configuration file. Consult the documentation of the
 *           plugin for new information. Consult adi_dmc_2156x_config.c file for the default DMC settings used.
 *
 *           Consult the readme.txt file for more information on building the project for Init code and Preload code.
 */


/*!
* @file      2156x_InitPreload_code.c
*
* @brief     Initialization and Preload code for 2156x series of processors.
*
* @details
*            Initialization and Preload code for 2156x series of processors.
*/

#include "2156x_InitPreload_code.h"

/* CLKIN must be defined so confirm it is. */
#if !defined(CLKIN)
  #error CLKIN macro define is required - add it to config.h
#endif

#define CONFIG_BOOT_SPI_CLOCK_VAL	(3u)

/* Confirm that macros for SPI/OSPI Clock Rate configuration are defined when necessary. */
#if defined(CONFIG_BOOT_SPI_CLOCK_RATE) && CONFIG_BOOT_SPI_CLOCK_RATE==1 && \
    !defined(CONFIG_BOOT_SPI_CLOCK_VAL)
  #error CONFIG_BOOT_SPI_CLOCK_VAL needs to be defined to the SPI clock rate value.
#endif

#if defined(CONFIG_BOOT_OSPI_CLOCK_RATE) && CONFIG_BOOT_OSPI_CLOCK_RATE==1
  #if !defined(CONFIG_BOOT_OSPI_CLOCK_VAL)
    #error CONFIG_BOOT_OSPI_CLOCK_VAL needs to be defined to the OSPI clock rate value.
  #endif
  #if !defined(CONFIG_BOOT_OSPI_READCAPDELAY)
    #error CONFIG_BOOT_OSPI_READCAPDELAY needs to be defined to the OSPI Read Cap Delay value
  #endif
#endif

#ifdef _MISRA_RULES
#pragma diag(suppress:misra_rule_16_7:"initcode pointer parameter is non-const")
#endif

/*
 * \var bool bError
 */
bool bError = false;

/*
 * \var unsigned int lastErrLinePos
 */
uint32_t lastErrLinePos = 0UL;

/*
 * \var unsigned int errCount
 */
uint32_t errCount = 0UL;

/**
 * @brief       The main code for Preload code for 2156x series of processors.
 * @details     The main code for Preload code for 2156x series of processors.
 *              Not used for Init code.
 *
 * @param[in]   NULL
 *
 * @return      NULL
 *
 * @sa          adi_pwr_Init()
 *              adi_pwr_cfg0_init()
 *              adi_uart_baud_read()
 *              adi_dmc_lane_reset()
 *              adi_dmc_cfg0_init()
 *              adi_uart_baud_init()
 *              adi_spi_clock_rate()
 *              adi_ospi_clock_rate()
 *              adi_smpu_cfg0_init()
 **/
#if defined (PRELOAD_CODE)
int main(int argc, char *argv[])
{
    /* Initialize components*/
    adi_initComponents();

    /* Initialize Init code. We don't process boot struct in preload case*/
    initcode(NULL);

    return 0;
}
#endif

/**
 * @brief       Initialization and Preload code for 2156x series of processors.
 * @details     Initialization and Preload code for 2156x series of processors.
 *              When Preload code is built, this function is called by the main()
 *              When Init code is built, this function is directly called by the BOOT ROM
 *
 * @param[in]   pBootStruct Pointer to ADI_ROM_BOOT_CONFIG to process boot structure parameters
 *
 * @return      NULL
 **/
#pragma retain_name /* retain resolved initcode entry */
uint32_t initcode(ADI_ROM_BOOT_CONFIG* pBootStruct)
{
    uint32_t result = 0UL;
    uint32_t UART_Baud_Rate_Val = 0UL;
#if CONFIG_DMC0
    bool bDMC0 = true;
#else
    bool bDMC0 = false;
#endif
#if CONFIG_SPIFLASH
    bool bSPIflash = true;
#else
    bool bSPIflash  = false;
#endif

    /*Initialize Power Service*/
    result = (uint32_t)adi_pwr_Init((uint8_t)ADI_PWR_CGU0, (uint32_t)CLKIN);
    CheckResult(result, (uint32_t) __LINE__);

#if CONFIG_BOOT_UART_BAUD_RATE
    /* Read UART Baud Rate*/
    UART_Baud_Rate_Val = adi_uart_baud_read();
    result = (UART_Baud_Rate_Val == 0UL) ? 1UL : 0UL;
    CheckResult(result, (uint32_t) __LINE__);
#endif

#if CONFIG_DMC0
    /* Set DMC Lane Reset*/
    adi_dmc_lane_reset(true);
#endif

    /* Initialize CGU and CDU*/
    result = (uint32_t)adi_pwr_cfg0_init();
    CheckResult(result, (uint32_t) __LINE__);

#if CONFIG_DMC0
    /* Clear DMC Lane Reset*/
    adi_dmc_lane_reset(false);

    /* Initialize DMC*/
    result = adi_dmc_cfg0_init();
    CheckResult(result, (uint32_t) __LINE__);
#endif

    /* Initialize SMPU to restrict access on unpopulated memories*/
    result = adi_smpu_cfg0_init(bDMC0, bSPIflash);
    CheckResult(result, (uint32_t) __LINE__);

#if CONFIG_BOOT_UART_BAUD_RATE
    /* Reinitialize UART Baud Rate*/
    result = adi_uart_baud_init(UART_Baud_Rate_Val);
    CheckResult(result, (uint32_t) __LINE__);
#endif

#if CONFIG_BOOT_SPI_CLOCK_RATE
    /* Reinitialize SPI Clock Rate*/
    result = adi_spi_clock_rate((uint32_t)CONFIG_BOOT_SPI_CLOCK_VAL);
    CheckResult(result, (uint32_t) __LINE__);
#endif

#if CONFIG_BOOT_OSPI_CLOCK_RATE
    /* Reinitialize SPI Clock Rate*/
    result = adi_ospi_clock_rate((uint32_t)CONFIG_BOOT_OSPI_CLOCK_VAL, (uint8_t)CONFIG_BOOT_OSPI_READCAPDELAY);
    CheckResult(result, (uint32_t) __LINE__);
#endif


#if DO_PROCESS_BOOTSTRUCT
    if(pBootStruct != NULL)
    {
        result = Processbootstruct(pBootStruct);
        CheckResult(result, (uint32_t) __LINE__);
    }
#endif

    return 0u;
}

/*
 * Note errors if result code is not success.
 */
static void CheckResult(uint32_t result, const uint32_t lineErrPos)
{
    if(result != 0u)
    {
        bError = true;
        errCount++;
        lastErrLinePos = lineErrPos;

    #if EXECUTE_SAFE_STATE
        ExecuteSafecode();
    #endif
    }

}

/*
 * Execute a safe code if errors are detected.
 */
static void ExecuteSafecode()
{
    while(1)
    {
        ExecuteIdle();
    }

}

static void ExecuteIdle()
{
    asm("idle;");
}

static uint32_t Processbootstruct(ADI_ROM_BOOT_CONFIG* pBootStruct)
{
    /*
     * Process the boot structure as required here. By default, the structure is not processed.
     * Refer to Hardware Reference Manual for more information on boot structures.
     * Refer to ADI_ROM_BOOT_CONFIG definition for the structure type passed.
     */

    return 0u;
}

/*@}*/
